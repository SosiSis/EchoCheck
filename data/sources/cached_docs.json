{
  "documents": [
    {
      "content": "API ReferenceAPIsuseuseis a React API that lets you read the value of a resource like aPromiseorcontext.constvalue=use(resource);Referenceuse(resource)UsageReading context withuseStreaming data from the server to the clientDealing with rejected PromisesTroubleshooting‚ÄúSuspense Exception: This is not a real error!‚ÄùReferenceuse(resource)Callusein your component to read the value of a resource like aPromiseorcontext.import{use}from'react';functionMessageComponent({messagePromise}){constmessage=use(messagePromise);consttheme=use(ThemeContext);// ...Unlike React Hooks,usecan be called within loops and conditional statements likeif. Like React Hooks, the function that callsusemust be a Component or Hook.When called with a Promise, theuseAPI integrates withSuspenseanderror boundaries. The component callingusesuspendswhile the Promise passed touseis pending. If the component that callsuseis wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by theuseAPI. If the Promise passed touseis rejected, the fallback of the nearest Error Boundary will be displayed.See more examples below.Parametersresource: this is the source of the data you want to read a value from. A resource can be aPromiseor acontext.ReturnsTheuseAPI returns the value that was read from the resource like the resolved value of aPromiseorcontext.CaveatsTheuseAPI must be called inside a Component or a Hook.When fetching data in aServer Component, preferasyncandawaitoveruse.asyncandawaitpick up rendering from the point whereawaitwas invoked, whereasusere-renders the component after the data is resolved.Prefer creating Promises inServer Componentsand passing them toClient Componentsover creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders.See this example.UsageReading context withuseWhen acontextis passed touse, it works similarly touseContext. WhileuseContextmust be called at the top level of your component,usecan be called inside conditionals likeifand loops likefor.useis preferred overuseContextbecause it is more flexible.import{use}from'react';functionButton(){consttheme=use(ThemeContext);// ...usereturns thecontext valuefor thecontextyou passed. To determine the context value, React searches the component tree and findsthe closest context provider abovefor that particular context.To pass context to aButton, wrap it or one of its parent components into the corresponding context provider.functionMyPage(){return(<ThemeContextvalue=\"dark\"><Form/></ThemeContext>);}functionForm(){// ... renders buttons inside ...}It doesn‚Äôt matter how many layers of components there are between the provider and theButton. When aButtonanywhereinside ofFormcallsuse(ThemeContext), it will receive\"dark\"as the value.UnlikeuseContext,usecan be called in conditionals and loops likeif.functionHorizontalRule({show}){if(show){consttheme=use(ThemeContext);return<hrclassName={theme}/>;}returnfalse;}useis called from inside aifstatement, allowing you to conditionally read values from a Context.PitfallLikeuseContext,use(context)always looks for the closest context providerabovethe component that calls it. It searches upwards anddoes notconsider context providers in the component from which you‚Äôre callinguse(context).App.jsApp.jsReloadClearForkimport{createContext,use}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){return(<ThemeContextvalue=\"dark\"><Form/></ThemeContext>)}functionForm(){return(<Paneltitle=\"Welcome\"><Buttonshow={true}>Sign up</Button><Buttonshow={false}>Log in</Button></Panel>);}functionPanel({title,children}){consttheme=use(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({show,children}){if(show){consttheme=use(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}returnfalse}Show moreStreaming data from the server to the clientData can be streamed from the server to the client by passing a Promise as a prop from aServer Componentto aClient Component.import{fetchMessage}from'./lib.js';import{Message}from'./message.js';exportdefaultfunctionApp(){constmessagePromise=fetchMessage();return(<Suspensefallback={<p>waiting for message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}TheClient Componentthen takesthe Promise it received as a propand passes it to theuseAPI. This allows theClient Componentto read the value fromthe Promisethat was initially created by the Server Component.// message.js'use client';import{use}from'react';exportfunctionMessage({messagePromise}){constmessageContent=use(messagePromise);return<p>Here is the message:{messageContent}</p>;}BecauseMessageis wrapped inSuspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by theuseAPI and theMessagecomponent will replace the Suspense fallback.message.jsmessage.jsReloadClearFork\"use client\";import{use,Suspense}from\"react\";functionMessage({messagePromise}){constmessageContent=use(messagePromise);return<p>Here is the message:{messageContent}</p>;}exportfunctionMessageContainer({messagePromise}){return(<Suspensefallback={<p>‚åõDownloading message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}Show moreNoteWhen passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren‚Äôt serializable and cannot be the resolved value of such a Promise.Deep DiveShould I resolve a Promise in a Server or Client Component?Show DetailsA Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with theuseAPI. You can also resolve the Promise in a Server Component withawaitand pass the required data to the Client Component as a prop.exportdefaultasyncfunctionApp(){constmessageContent=awaitfetchMessage();return<MessagemessageContent={messageContent}/>}But usingawaitin aServer Componentwill block its rendering until theawaitstatement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.Dealing with rejected PromisesIn some cases a Promise passed tousecould be rejected. You can handle rejected Promises by either:Displaying an error to users with an error boundary.Providing an alternative value withPromise.catchPitfallusecannot be called in a try-catch block. Instead of a try-catch blockwrap your component in an Error Boundary, orprovide an alternative value to use with the Promise‚Äôs.catchmethod.Displaying an error to users with an error boundaryIf you‚Äôd like to display an error to your users when a Promise is rejected, you can use anerror boundary. To use an error boundary, wrap the component where you are calling theuseAPI in an error boundary. If the Promise passed touseis rejected the fallback for the error boundary will be displayed.message.jsmessage.jsReloadClearFork\"use client\";import{use,Suspense}from\"react\";import{ErrorBoundary}from\"react-error-boundary\";exportfunctionMessageContainer({messagePromise}){return(<ErrorBoundaryfallback={<p>‚ö†Ô∏èSomething went wrong</p>}><Suspensefallback={<p>‚åõDownloading message...</p>}><MessagemessagePromise={messagePromise}/></Suspense></ErrorBoundary>);}functionMessage({messagePromise}){constcontent=use(messagePromise);return<p>Here is the message:{content}</p>;}Show moreProviding an alternative value withPromise.catchIf you‚Äôd like to provide an alternative value when the Promise passed touseis rejected you can use the Promise‚Äôscatchmethod.import{Message}from'./message.js';exportdefaultfunctionApp(){constmessagePromise=newPromise((resolve,reject)=>{reject();}).catch(()=>{return\"no new message found.\";});return(<Suspensefallback={<p>waiting for message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}To use the Promise‚Äôscatchmethod, callcatchon the Promise object.catchtakes a single argument: a function that takes an error message as an argument. Whatever isreturnedby the function passed tocatchwill be used as the resolved value of the Promise.Troubleshooting‚ÄúSuspense Exception: This is not a real error!‚ÄùYou are either callinguseoutside of a React Component or Hook function, or callingusein a try‚Äìcatch block. If you are callinguseinside a try‚Äìcatch block, wrap your component in an error boundary, or call the Promise‚Äôscatchto catch the error and resolve the Promise with another value.See these examples.If you are callinguseoutside a React Component or Hook function, move theusecall to a React Component or Hook function.functionMessageComponent({messagePromise}){functiondownload(){// ‚ùå the function calling `use` is not a Component or Hookconstmessage=use(messagePromise);// ...Instead, calluseoutside any component closures, where the function that callsuseis a Component or Hook.functionMessageComponent({messagePromise}){// ‚úÖ `use` is being called from a component.constmessage=use(messagePromise);// ...PreviousstartTransitionNextexperimental_taintObjectReference",
      "metadata": {
        "source": "react-official",
        "url": "https://react.dev/reference/react/use",
        "type": "documentation",
        "framework": "react",
        "fetched_at": 1757098336.5775397
      }
    },
    {
      "content": "Learn ReactEscape HatchesSynchronizing with EffectsSome components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen.Effectslet you run some code after rendering so that you can synchronize your component with some system outside of React.You will learnWhat Effects areHow Effects are different from eventsHow to declare an Effect in your componentHow to skip re-running an Effect unnecessarilyWhy Effects run twice in development and how to fix themWhat are Effects and how are they different from events?Before getting to Effects, you need to be familiar with two types of logic inside React components:Rendering code(introduced inDescribing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen.Rendering code must be pure.Like a math formula, it should onlycalculatethe result, but not do anything else.Event handlers(introduced inAdding Interactivity) are nested functions inside your components thatdothings rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain‚Äúside effects‚Äù(they change the program‚Äôs state) caused by a specific user action (for example, a button click or typing).Sometimes this isn‚Äôt enough. Consider aChatRoomcomponent that must connect to the chat server whenever it‚Äôs visible on the screen. Connecting to a server is not a pure calculation (it‚Äôs a side effect) so it can‚Äôt happen during rendering. However, there is no single particular event like a click that causesChatRoomto be displayed.Effectslet you specify side effects that are caused by rendering itself, rather than by a particular event.Sending a message in the chat is aneventbecause it is directly caused by the user clicking a specific button. However, setting up a server connection is anEffectbecause it should happen no matter which interaction caused the component to appear. Effects run at the end of acommitafter the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).NoteHere and later in this text, capitalized ‚ÄúEffect‚Äù refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we‚Äôll say ‚Äúside effect‚Äù.You might not need an EffectDon‚Äôt rush to add Effects to your components.Keep in mind that Effects are typically used to ‚Äústep out‚Äù of your React code and synchronize with someexternalsystem. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state,you might not need an Effect.How to write an EffectTo write an Effect, follow these three steps:Declare an Effect.By default, your Effect will run after everycommit.Specify the Effect dependencies.Most Effects should only re-runwhen neededrather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifyingdependencies.Add cleanup if needed.Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, ‚Äúconnect‚Äù needs ‚Äúdisconnect‚Äù, ‚Äúsubscribe‚Äù needs ‚Äúunsubscribe‚Äù, and ‚Äúfetch‚Äù needs either ‚Äúcancel‚Äù or ‚Äúignore‚Äù. You will learn how to do this by returning acleanup function.Let‚Äôs look at each of these steps in detail.Step 1: Declare an EffectTo declare an Effect in your component, import theuseEffectHookfrom React:import{useEffect}from'react';Then, call it at the top level of your component and put some code inside your Effect:functionMyComponent(){useEffect(()=>{// Code here will run after *every* render});return<div/>;}Every time your component renders, React will update the screenand thenrun the code insideuseEffect. In other words,useEffect‚Äúdelays‚Äù a piece of code from running until that render is reflected on the screen.Let‚Äôs see how you can use an Effect to synchronize with an external system. Consider a<VideoPlayer>React component. It would be nice to control whether it‚Äôs playing or paused by passing anisPlayingprop to it:<VideoPlayerisPlaying={isPlaying}/>;Your customVideoPlayercomponent renders the built-in browser<video>tag:functionVideoPlayer({src,isPlaying}){// TODO: do something with isPlayingreturn<videosrc={src}/>;}However, the browser<video>tag does not have anisPlayingprop. The only way to control it is to manually call theplay()andpause()methods on the DOM element.You need to synchronize the value ofisPlayingprop, which tells whether the videoshouldcurrently be playing, with calls likeplay()andpause().We‚Äôll need to firstget a refto the<video>DOM node.You might be tempted to try to callplay()orpause()during rendering, but that isn‚Äôt correct:App.jsApp.jsReloadClearForkimport{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);if(isPlaying){ref.current.play();// Calling these while rendering isn't allowed.}else{ref.current.pause();// Also, this crashes.}return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);return(<><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}Show moreThe reason this code isn‚Äôt correct is that it tries to do something with the DOM node during rendering. In React,rendering should be a pure calculationof JSX and should not contain side effects like modifying the DOM.Moreover, whenVideoPlayeris called for the first time, its DOM does not exist yet! There isn‚Äôt a DOM node yet to callplay()orpause()on, because React doesn‚Äôt know what DOM to create until you return the JSX.The solution here is towrap the side effect withuseEffectto move it out of the rendering calculation:import{useEffect,useRef}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.When yourVideoPlayercomponent renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the<video>tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will callplay()orpause()depending on the value ofisPlaying.Press Play/Pause multiple times and see how the video player stays synchronized to theisPlayingvalue:App.jsApp.jsReloadClearForkimport{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);return(<><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}Show moreIn this example, the ‚Äúexternal system‚Äù you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.Note that controlling a video player is much more complex in practice. Callingplay()may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.PitfallBy default, Effects run aftereveryrender. This is why code like this willproduce an infinite loop:const[count,setCount]=useState(0);useEffect(()=>{setCount(count+1);});Effects run as aresultof rendering. Setting statetriggersrendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.Effects should usually synchronize your components with anexternalsystem. If there‚Äôs no external system and you only want to adjust some state based on other state,you might not need an Effect.Step 2: Specify the Effect dependenciesBy default, Effects run aftereveryrender. Often, this isnot what you want:Sometimes, it‚Äôs slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it‚Äôs necessary. For example, you don‚Äôt want to reconnect to the chat server on every keystroke.Sometimes, it‚Äôs wrong. For example, you don‚Äôt want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time.To demonstrate the issue, here is the previous example with a fewconsole.logcalls and a text input that updates the parent component‚Äôs state. Notice how typing causes the Effect to re-run:App.jsApp.jsReloadClearForkimport{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}Show moreYou can tell React toskip unnecessarily re-running the Effectby specifying an array ofdependenciesas the second argument to theuseEffectcall. Start by adding an empty[]array to the above example on line 14:useEffect(()=>{// ...},[]);You should see an error sayingReact Hook useEffect has a missing dependency: 'isPlaying':App.jsApp.jsReloadClearForkimport{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}},[]);// This causes an errorreturn<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}Show moreThe problem is that the code inside of your Effectdepends ontheisPlayingprop to decide what to do, but this dependency was not explicitly declared. To fix this issue, addisPlayingto the dependency array:useEffect(()=>{if(isPlaying){// It's used here...// ...}else{// ...}},[isPlaying]);// ...so it must be declared here!Now all dependencies are declared, so there is no error. Specifying[isPlaying]as the dependency array tells React that it should skip re-running your Effect ifisPlayingis the same as it was during the previous render. With this change, typing into the input doesn‚Äôt cause the Effect to re-run, but pressing Play/Pause does:App.jsApp.jsReloadClearForkimport{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}},[isPlaying]);return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}Show moreThe dependency array can contain multiple dependencies. React will only skip re-running the Effect ifallof the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using theObject.iscomparison. See theuseEffectreferencefor details.Notice that you can‚Äôt ‚Äúchoose‚Äù your dependencies.You will get a lint error if the dependencies you specified don‚Äôt match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don‚Äôt want some code to re-run,edit the Effect code itselfto not ‚Äúneed‚Äù that dependency.PitfallThe behaviors without the dependency array and with anempty[]dependency array are different:useEffect(()=>{// This runs after every render});useEffect(()=>{// This runs only on mount (when the component appears)},[]);useEffect(()=>{// This runs on mount *and also* if either a or b have changed since the last render},[a,b]);We‚Äôll take a close look at what ‚Äúmount‚Äù means in the next step.Deep DiveWhy was the ref omitted from the dependency array?Show DetailsThis Effect usesbothrefandisPlaying, but onlyisPlayingis declared as a dependency:functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}},[isPlaying]);This is because therefobject has astable identity:React guaranteesyou‚Äôll always get the same objectfrom the sameuseRefcall on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}},[isPlaying,ref]);Thesetfunctionsreturned byuseStatealso have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.Omitting always-stable dependencies only works when the linter can ‚Äúsee‚Äù that the object is stable. For example, ifrefwas passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can‚Äôt know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effectwoulddepend on which ref is passed.Step 3: Add cleanup if neededConsider a different example. You‚Äôre writing aChatRoomcomponent that needs to connect to the chat server when it appears. You are given acreateConnection()API that returns an object withconnect()anddisconnect()methods. How do you keep the component connected while it is displayed to the user?Start by writing the Effect logic:useEffect(()=>{constconnection=createConnection();connection.connect();});It would be slow to connect to the chat after every re-render, so you add the dependency array:useEffect(()=>{constconnection=createConnection();connection.connect();},[]);The code inside the Effect does not use any props or state, so your dependency array is[](empty). This tells React to only run this code when the component ‚Äúmounts‚Äù, i.e. appears on the screen for the first time.Let‚Äôs try running this code:App.jschat.jsApp.jsReloadClearForkimport{useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection();connection.connect();},[]);return<h1>Welcome to the chat!</h1>;}This Effect only runs on mount, so you might expect\"‚úÖ Connecting...\"to be printed once in the console.However, if you check the console,\"‚úÖ Connecting...\"gets printed twice. Why does it happen?Imagine theChatRoomcomponent is a part of a larger app with many different screens. The user starts their journey on theChatRoompage. The component mounts and callsconnection.connect(). Then imagine the user navigates to another screen‚Äîfor example, to the Settings page. TheChatRoomcomponent unmounts. Finally, the user clicks Back andChatRoommounts again. This would set up a second connection‚Äîbut the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.Seeing the\"‚úÖ Connecting...\"log twice helps you notice the real issue: your code doesn‚Äôt close the connection when the component unmounts.To fix the issue, return acleanup functionfrom your Effect:useEffect(()=>{constconnection=createConnection();connection.connect();return()=>{connection.disconnect();};},[]);React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let‚Äôs see what happens when the cleanup function is implemented:App.jschat.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection();connection.connect();return()=>connection.disconnect();},[]);return<h1>Welcome to the chat!</h1>;}Now you get three console logs in development:\"‚úÖ Connecting...\"\"‚ùå Disconnected.\"\"‚úÖ Connecting...\"This is the correct behavior in development.By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There‚Äôs an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal‚Äîdon‚Äôt try to make it go away!In production, you would only see\"‚úÖ Connecting...\"printed once.Remounting components only happens in development to help you find Effects that need cleanup. You can turn offStrict Modeto opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.How to handle the Effect firing twice in development?React intentionally remounts your components in development to find bugs like in the last example.The right question isn‚Äôt ‚Äúhow to run an Effect once‚Äù, but ‚Äúhow to fix my Effect so that it works after remounting‚Äù.Usually, the answer is to implement the cleanup function.  The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the Effect running once (as in production) and asetup ‚Üí cleanup ‚Üí setupsequence (as you‚Äôd see in development).Most of the Effects you‚Äôll write will fit into one of the common patterns below.PitfallDon‚Äôt use refs to prevent Effects from firingA common pitfall for preventing Effects firing twice in development is to use arefto prevent the Effect from running more than once. For example, you could ‚Äúfix‚Äù the above bug with auseRef:constconnectionRef=useRef(null);useEffect(()=>{// üö© This wont fix the bug!!!if(!connectionRef.current){connectionRef.current=createConnection();connectionRef.current.connect();}},[]);This makes it so you only see\"‚úÖ Connecting...\"once in development, but it doesn‚Äôt fix the bug.When the user navigates away, the connection still isn‚Äôt closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the ‚Äúfix‚Äù.To fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above.See the examples below for how to handle common patterns.Controlling non-React widgetsSometimes you need to add UI widgets that aren‚Äôt written in React. For example, let‚Äôs say you‚Äôre adding a map component to your page. It has asetZoomLevel()method, and you‚Äôd like to keep the zoom level in sync with azoomLevelstate variable in your React code. Your Effect would look similar to this:useEffect(()=>{constmap=mapRef.current;map.setZoomLevel(zoomLevel);},[zoomLevel]);Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because callingsetZoomLeveltwice with the same value does not do anything. It may be slightly slower, but this doesn‚Äôt matter because it won‚Äôt remount needlessly in production.Some APIs may not allow you to call them twice in a row. For example, theshowModalmethod of the built-in<dialog>element throws if you call it twice. Implement the cleanup function and make it close the dialog:useEffect(()=>{constdialog=dialogRef.current;dialog.showModal();return()=>dialog.close();},[]);In development, your Effect will callshowModal(), then immediatelyclose(), and thenshowModal()again. This has the same user-visible behavior as callingshowModal()once, as you would see in production.Subscribing to eventsIf your Effect subscribes to something, the cleanup function should unsubscribe:useEffect(()=>{functionhandleScroll(e){console.log(window.scrollX,window.scrollY);}window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);In development, your Effect will calladdEventListener(), then immediatelyremoveEventListener(), and thenaddEventListener()again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as callingaddEventListener()once, as in production.Triggering animationsIf your Effect animates something in, the cleanup function should reset the animation to the initial values:useEffect(()=>{constnode=ref.current;node.style.opacity=1;// Trigger the animationreturn()=>{node.style.opacity=0;// Reset to the initial value};},[]);In development, opacity will be set to1, then to0, and then to1again. This should have the same user-visible behavior as setting it to1directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.Fetching dataIf your Effect fetches something, the cleanup function should eitherabort the fetchor ignore its result:useEffect(()=>{letignore=false;asyncfunctionstartFetching(){constjson=awaitfetchTodos(userId);if(!ignore){setTodos(json);}}startFetching();return()=>{ignore=true;};},[userId]);You can‚Äôt ‚Äúundo‚Äù a network request that already happened, but your cleanup function should ensure that the fetch that‚Äôsnot relevant anymoredoes not keep affecting your application. If theuserIdchanges from'Alice'to'Bob', cleanup ensures that the'Alice'response is ignored even if it arrives after'Bob'.In development, you will see two fetches in the Network tab.There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of theignorevariable will be set totrue. So even though there is an extra request, it won‚Äôt affect the state thanks to theif (!ignore)check.In production, there will only be one request.If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:functionTodoList(){consttodos=useSomeDataLibrary(`/api/user/${userId}/todos`);// ...This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won‚Äôt have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.Deep DiveWhat are good alternatives to data fetching in Effects?Show DetailsWritingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:Effects don‚Äôt run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.Fetching directly in Effects usually means you don‚Äôt preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.It‚Äôs not very ergonomic.There‚Äôs quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn‚Äôt suffer from bugs likerace conditions.This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.Otherwise, consider using or building a client-side cache.Popular open source solutions includeReact Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).You can continue fetching data directly in Effects if neither of these approaches suit you.Sending analyticsConsider this code that sends an analytics event on the page visit:useEffect(()=>{logVisit(url);// Sends a POST request},[url]);In development,logVisitwill be called twice for every URL, so you might be tempted to try to fix that.We recommend keeping this code as is.Like with earlier examples, there is nouser-visiblebehavior difference between running it once and running it twice. From a practical point of view,logVisitshould not do anything in development because you don‚Äôt want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.In production, there will be no duplicate visit logs.To debug the analytics events you‚Äôre sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out ofStrict Modeand its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics,intersection observerscan help track which components are in the viewport and how long they remain visible.Not an Effect: Initializing the applicationSome logic should only run once when the application starts. You can put it outside your components:if(typeofwindow!=='undefined'){// Check if we're running in the browser.checkAuthToken();loadDataFromLocalStorage();}functionApp(){// ...}This guarantees that such logic only runs once after the browser loads the page.Not an Effect: Buying a productSometimes, even if you write a cleanup function, there‚Äôs no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:useEffect(()=>{// üî¥ Wrong: This Effect fires twice in development, exposing a problem in the code.fetch('/api/buy',{method:'POST'});},[]);You wouldn‚Äôt want to buy the product twice. However, this is also why you shouldn‚Äôt put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don‚Äôt want to buy the product when the uservisitsa page; you want to buy it when the userclicksthe Buy button.Buying is not caused by rendering; it‚Äôs caused by a specific interaction. It should run only when the user presses the button.Delete the Effect and move your/api/buyrequest into the Buy button event handler:functionhandleClick(){// ‚úÖ Buying is an event because it is caused by a particular interaction.fetch('/api/buy',{method:'POST'});}This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.From a user‚Äôs perspective, visiting a page shouldn‚Äôt be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.Putting it all togetherThis playground can help you ‚Äúget a feel‚Äù for how Effects work in practice.This example usessetTimeoutto schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing ‚ÄúMount the component‚Äù:App.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';functionPlayground(){const[text,setText]=useState('a');useEffect(()=>{functiononTimeout(){console.log('‚è∞ '+text);}console.log('üîµ Schedule \"'+text+'\" log');consttimeoutId=setTimeout(onTimeout,3000);return()=>{console.log('üü° Cancel \"'+text+'\" log');clearTimeout(timeoutId);};},[text]);return(<><label>What to log:{' '}<inputvalue={text}onChange={e=>setText(e.target.value)}/></label><h1>{text}</h1></>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);return(<><buttononClick={()=>setShow(!show)}>{show?'Unmount':'Mount'}the component</button>{show&&<hr/>}{show&&<Playground/>}</>);}Show moreYou will see three logs at first:Schedule \"a\" log,Cancel \"a\" log, andSchedule \"a\" logagain. Three second later there will also be a log sayinga. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you‚Äôve implemented cleanup well.Now edit the input to sayabc. If you do it fast enough, you‚Äôll seeSchedule \"ab\" logimmediately followed byCancel \"ab\" logandSchedule \"abc\" log.React always cleans up the previous render‚Äôs Effect before the next render‚Äôs Effect.This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.Type something into the input and then immediately press ‚ÄúUnmount the component‚Äù. Notice how unmounting cleans up the last render‚Äôs Effect. Here, it clears the last timeout before it has a chance to fire.Finally, edit the component above and comment out the cleanup function so that the timeouts don‚Äôt get cancelled. Try typingabcdefast. What do you expect to happen in three seconds? Willconsole.log(text)inside the timeout print thelatesttextand produce fiveabcdelogs? Give it a try to check your intuition!Three seconds later, you should see a sequence of logs (a,ab,abc,abcd, andabcde) rather than fiveabcdelogs.Each Effect ‚Äúcaptures‚Äù thetextvalue from its corresponding render.It doesn‚Äôt matter that thetextstate changed: an Effect from the render withtext = 'ab'will always see'ab'. In other words, Effects from each render are isolated from each other. If you‚Äôre curious how this works, you can read aboutclosures.Deep DiveEach render has its own EffectsShow DetailsYou can think ofuseEffectas ‚Äúattaching‚Äù a piece of behavior to the render output. Consider this Effect:exportdefaultfunctionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(roomId);connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to{roomId}!</h1>;}Let‚Äôs see what exactly happens as the user navigates around the app.Initial renderThe user visits<ChatRoom roomId=\"general\" />. Let‚Äôsmentally substituteroomIdwith'general':// JSX for the first render (roomId = \"general\")return<h1>Welcome to general!</h1>;The Effect isalsoa part of the rendering output.The first render‚Äôs Effect becomes:// Effect for the first render (roomId = \"general\")()=>{constconnection=createConnection('general');connection.connect();return()=>connection.disconnect();},// Dependencies for the first render (roomId = \"general\")['general']React runs this Effect, which connects to the'general'chat room.Re-render with same dependenciesLet‚Äôs say<ChatRoom roomId=\"general\" />re-renders. The JSX output is the same:// JSX for the second render (roomId = \"general\")return<h1>Welcome to general!</h1>;React sees that the rendering output has not changed, so it doesn‚Äôt update the DOM.The Effect from the second render looks like this:// Effect for the second render (roomId = \"general\")()=>{constconnection=createConnection('general');connection.connect();return()=>connection.disconnect();},// Dependencies for the second render (roomId = \"general\")['general']React compares['general']from the second render with['general']from the first render.Because all dependencies are the same, Reactignoresthe Effect from the second render.It never gets called.Re-render with different dependenciesThen, the user visits<ChatRoom roomId=\"travel\" />. This time, the component returns different JSX:// JSX for the third render (roomId = \"travel\")return<h1>Welcome to travel!</h1>;React updates the DOM to change\"Welcome to general\"into\"Welcome to travel\".The Effect from the third render looks like this:// Effect for the third render (roomId = \"travel\")()=>{constconnection=createConnection('travel');connection.connect();return()=>connection.disconnect();},// Dependencies for the third render (roomId = \"travel\")['travel']React compares['travel']from the third render with['general']from the second render. One dependency is different:Object.is('travel', 'general')isfalse. The Effect can‚Äôt be skipped.Before React can apply the Effect from the third render, it needs to clean up the last Effect thatdidrun.The second render‚Äôs Effect was skipped, so React needs to clean up the first render‚Äôs Effect. If you scroll up to the first render, you‚Äôll see that its cleanup callsdisconnect()on the connection that was created withcreateConnection('general'). This disconnects the app from the'general'chat room.After that, React runs the third render‚Äôs Effect. It connects to the'travel'chat room.UnmountFinally, let‚Äôs say the user navigates away, and theChatRoomcomponent unmounts. React runs the last Effect‚Äôs cleanup function. The last Effect was from the third render. The third render‚Äôs cleanup destroys thecreateConnection('travel')connection. So the app disconnects from the'travel'room.Development-only behaviorsWhenStrict Modeis on, React remounts every component once after mount (state and DOM are preserved). Thishelps you find Effects that need cleanupand exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.RecapUnlike events, Effects are caused by rendering itself rather than a particular interaction.Effects let you synchronize a component with some external system (third-party API, network, etc).By default, Effects run after every render (including the initial one).React will skip the Effect if all of its dependencies have the same values as during the last render.You can‚Äôt ‚Äúchoose‚Äù your dependencies. They are determined by the code inside the Effect.Empty dependency array ([]) corresponds to the component ‚Äúmounting‚Äù, i.e. being added to the screen.In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.If your Effect breaks because of remounting, you need to implement a cleanup function.React will call your cleanup function before the Effect runs next time, and during the unmount.Try out some challenges1.Focus a field on mount2.Focus a field conditionally3.Fix an interval that fires twice4.Fix fetching inside an EffectChallenge1of4:Focus a field on mountIn this example, the form renders a<MyInput />component.Use the input‚Äôsfocus()method to makeMyInputautomatically focus when it appears on the screen. There is already a commented out implementation, but it doesn‚Äôt quite work. Figure out why it doesn‚Äôt work, and fix it. (If you‚Äôre familiar with theautoFocusattribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)MyInput.jsMyInput.jsReloadClearForkimport{useEffect,useRef}from'react';exportdefaultfunctionMyInput({value,onChange}){constref=useRef(null);// TODO: This doesn't quite work. Fix it.// ref.current.focus()return(<inputref={ref}value={value}onChange={onChange}/>);}Show moreTo verify that your solution works, press ‚ÄúShow form‚Äù and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press ‚ÄúHide form‚Äù and ‚ÄúShow form‚Äù again. Verify the input is highlighted again.MyInputshould only focuson mountrather than after every render. To verify that the behavior is right, press ‚ÄúShow form‚Äù and then repeatedly press the ‚ÄúMake it uppercase‚Äù checkbox. Clicking the checkbox shouldnotfocus the input above it.Show solutionNextChallengePreviousManipulating the DOM with RefsNextYou Might Not Need an Effect",
      "metadata": {
        "source": "react-official",
        "url": "https://react.dev/learn/synchronizing-with-effects",
        "type": "documentation",
        "framework": "react",
        "fetched_at": 1757098343.1321065
      }
    },
    {
      "content": "API ReferenceHooksuseStateuseStateis a React Hook that lets you add astate variableto your component.const[state,setState]=useState(initialState)ReferenceuseState(initialState)setfunctions, likesetSomething(nextState)UsageAdding state to a componentUpdating state based on the previous stateUpdating objects and arrays in stateAvoiding recreating the initial stateResetting state with a keyStoring information from previous rendersTroubleshootingI‚Äôve updated the state, but logging gives me the old valueI‚Äôve updated the state, but the screen doesn‚Äôt updateI‚Äôm getting an error: ‚ÄúToo many re-renders‚ÄùMy initializer or updater function runs twiceI‚Äôm trying to set state to a function, but it gets called insteadReferenceuseState(initialState)CalluseStateat the top level of your component to declare astate variable.import{useState}from'react';functionMyComponent(){const[age,setAge]=useState(28);const[name,setName]=useState('Taylor');const[todos,setTodos]=useState(()=>createTodos());// ...The convention is to name state variables like[something, setSomething]usingarray destructuring.See more examples below.ParametersinitialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below.ReturnsuseStatereturns an array with exactly two values:The current state. During the first render, it will match theinitialStateyou have passed.Thesetfunctionthat lets you update the state to a different value and trigger a re-render.CaveatsuseStateis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.In Strict Mode, React willcall your initializer function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.setfunctions, likesetSomething(nextState)Thesetfunction returned byuseStatelets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:const[name,setName]=useState('Edward');functionhandleClick(){setName('Taylor');setAge(a=>a+1);// ...ParametersnextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below.Returnssetfunctions do not have a return value.CaveatsThesetfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thesetfunction,you will still get the old valuethat was on the screen before your call.If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn‚Äôt affect your code.Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.Thesetfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.Calling thesetfunctionduring renderingis only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it tostore information from the previous renders.See an example below.In Strict Mode, React willcall your updater function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.UsageAdding state to a componentCalluseStateat the top level of your component to declare one or morestate variables.import{useState}from'react';functionMyComponent(){const[age,setAge]=useState(42);const[name,setName]=useState('Taylor');// ...The convention is to name state variables like[something, setSomething]usingarray destructuring.useStatereturns an array with exactly two items:Thecurrent stateof this state variable, initially set to theinitial stateyou provided.Thesetfunctionthat lets you change it to any other value in response to interaction.To update what‚Äôs on the screen, call thesetfunction with some next state:functionhandleClick(){setName('Robin');}React will store the next state, render your component again with the new values, and update the UI.PitfallCalling thesetfunctiondoes notchange the current state in the already executing code:functionhandleClick(){setName('Robin');console.log(name);// Still \"Taylor\"!}It only affects whatuseStatewill return starting from thenextrender.Basic useState examples1.Counter (number)2.Text field (string)3.Checkbox (boolean)4.Form (two variables)Example1of4:Counter (number)In this example, thecountstate variable holds a number. Clicking the button increments it.App.jsApp.jsReloadClearForkimport{useState}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<buttononClick={handleClick}>You pressed me{count}times</button>);}NextExampleUpdating state based on the previous stateSuppose theageis42. This handler callssetAge(age + 1)three times:functionhandleClick(){setAge(age+1);// setAge(42 + 1)setAge(age+1);// setAge(42 + 1)setAge(age+1);// setAge(42 + 1)}However, after one click,agewill only be43rather than45! This is because calling thesetfunctiondoes not updatetheagestate variable in the already running code. So eachsetAge(age + 1)call becomessetAge(43).To solve this problem,you may pass anupdater functiontosetAgeinstead of the next state:functionhandleClick(){setAge(a=>a + 1);// setAge(42 => 43)setAge(a=>a + 1);// setAge(43 => 44)setAge(a=>a + 1);// setAge(44 => 45)}Here,a => a + 1is your updater function. It takes thepending stateand calculates thenext statefrom it.React puts your updater functions in aqueue.Then, during the next render, it will call them in the same order:a => a + 1will receive42as the pending state and return43as the next state.a => a + 1will receive43as the pending state and return44as the next state.a => a + 1will receive44as the pending state and return45as the next state.There are no other queued updates, so React will store45as the current state in the end.By convention, it‚Äôs common to name the pending state argument for the first letter of the state variable name, likeaforage. However, you may also call it likeprevAgeor something else that you find clearer.React maycall your updaters twicein development to verify that they arepure.Deep DiveIs using an updater always preferred?Show DetailsYou might hear a recommendation to always write code likesetAge(a => a + 1)if the state you‚Äôre setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, theagestate variable would be updated before the next click. This means there is no risk of a click handler seeing a ‚Äústale‚Äùageat the beginning of the event handler.However, if you do multiple updates within the same event, updaters can be helpful. They‚Äôre also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).If you prefer consistency over slightly more verbose syntax, it‚Äôs reasonable to always write an updater if the state you‚Äôre setting is calculated from the previous state. If it‚Äôs calculated from the previous state of someotherstate variable, you might want to combine them into one object anduse a reducer.The difference between passing an updater and passing the next state directly1.Passing the updater function2.Passing the next state directlyExample1of2:Passing the updater functionThis example passes the updater function, so the ‚Äú+3‚Äù button works.App.jsApp.jsReloadClearForkimport{useState}from'react';exportdefaultfunctionCounter(){const[age,setAge]=useState(42);functionincrement(){setAge(a=>a+1);}return(<><h1>Your age:{age}</h1><buttononClick={()=>{increment();increment();increment();}}>+3</button><buttononClick={()=>{increment();}}>+1</button></>);}Show moreNextExampleUpdating objects and arrays in stateYou can put objects and arrays into state. In React, state is considered read-only, soyou shouldreplaceit rather thanmutateyour existing objects. For example, if you have aformobject in state, don‚Äôt mutate it:// üö© Don't mutate an object in state like this:form.firstName='Taylor';Instead, replace the whole object by creating a new one:// ‚úÖ Replace state with a new objectsetForm({...form,firstName:'Taylor'});Readupdating objects in stateandupdating arrays in stateto learn more.Examples of objects and arrays in state1.Form (object)2.Form (nested object)3.List (array)4.Writing concise update logic with ImmerExample1of4:Form (object)In this example, theformstate variable holds an object. Each input has a change handler that callssetFormwith the next state of the entire form. The{ ...form }spread syntax ensures that the state object is replaced rather than mutated.App.jsApp.jsReloadClearForkimport{useState}from'react';exportdefaultfunctionForm(){const[form,setForm]=useState({firstName:'Barbara',lastName:'Hepworth',email:'bhepworth@sculpture.com',});return(<><label>First name:<inputvalue={form.firstName}onChange={e=>{setForm({...form,firstName:e.target.value});}}/></label><label>Last name:<inputvalue={form.lastName}onChange={e=>{setForm({...form,lastName:e.target.value});}}/></label><label>Email:<inputvalue={form.email}onChange={e=>{setForm({...form,email:e.target.value});}}/></label><p>{form.firstName}{' '}{form.lastName}{' '}({form.email})</p></>);}Show moreNextExampleAvoiding recreating the initial stateReact saves the initial state once and ignores it on the next renders.functionTodoList(){const[todos,setTodos]=useState(createInitialTodos());// ...Although the result ofcreateInitialTodos()is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating large arrays or performing expensive calculations.To solve this, you maypass it as aninitializerfunctiontouseStateinstead:functionTodoList(){const[todos,setTodos]=useState(createInitialTodos);// ...Notice that you‚Äôre passingcreateInitialTodos, which is thefunction itself, and notcreateInitialTodos(), which is the result of calling it. If you pass a function touseState, React will only call it during initialization.React maycall your initializers twicein development to verify that they arepure.The difference between passing an initializer and passing the initial state directly1.Passing the initializer function2.Passing the initial state directlyExample1of2:Passing the initializer functionThis example passes the initializer function, so thecreateInitialTodosfunction only runs during initialization. It does not run when component re-renders, such as when you type into the input.App.jsApp.jsReloadClearForkimport{useState}from'react';functioncreateInitialTodos(){constinitialTodos=[];for(leti=0;i<50;i++){initialTodos.push({id:i,text:'Item '+(i+1)});}returninitialTodos;}exportdefaultfunctionTodoList(){const[todos,setTodos]=useState(createInitialTodos);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>{setText('');setTodos([{id:todos.length,text:text},...todos]);}}>Add</button><ul>{todos.map(item=>(<likey={item.id}>{item.text}</li>))}</ul></>);}Show moreNextExampleResetting state with a keyYou‚Äôll often encounter thekeyattribute whenrendering lists.However, it also serves another purpose.You canreset a component‚Äôs state by passing a differentkeyto a component.In this example, the Reset button changes theversionstate variable, which we pass as akeyto theForm. When thekeychanges, React re-creates theFormcomponent (and all of its children) from scratch, so its state gets reset.Readpreserving and resetting stateto learn more.App.jsApp.jsReloadClearForkimport{useState}from'react';exportdefaultfunctionApp(){const[version,setVersion]=useState(0);functionhandleReset(){setVersion(version+1);}return(<><buttononClick={handleReset}>Reset</button><Formkey={version}/></>);}functionForm(){const[name,setName]=useState('Taylor');return(<><inputvalue={name}onChange={e=>setName(e.target.value)}/><p>Hello,{name}.</p></>);}Show moreStoring information from previous rendersUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering ‚Äî for example, you might want to change a state variable when a prop changes.In most cases, you don‚Äôt need this:If the value you need can be computed entirely from the current props or other state,remove that redundant state altogether.If you‚Äôre worried about recomputing too often, theuseMemoHookcan help.If you want to reset the entire component tree‚Äôs state,pass a differentkeyto your component.If you can, update all the relevant state in the event handlers.In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling asetfunction while your component is rendering.Here‚Äôs an example. ThisCountLabelcomponent displays thecountprop passed to it:exportdefaultfunctionCountLabel({count}){return<h1>{count}</h1>}Say you want to show whether the counter hasincreased or decreasedsince the last change. Thecountprop doesn‚Äôt tell you this ‚Äî you need to keep track of its previous value. Add theprevCountstate variable to track it. Add another state variable calledtrendto hold whether the count has increased or decreased. CompareprevCountwithcount, and if they‚Äôre not equal, update bothprevCountandtrend. Now you can show both the current count prop andhow it has changed since the last render.App.jsCountLabel.jsCountLabel.jsReloadClearForkimport{useState}from'react';exportdefaultfunctionCountLabel({count}){const[prevCount,setPrevCount]=useState(count);const[trend,setTrend]=useState(null);if(prevCount!==count){setPrevCount(count);setTrend(count>prevCount?'increasing':'decreasing');}return(<><h1>{count}</h1>{trend&&<p>The count is{trend}</p>}</>);}Show moreNote that if you call asetfunction while rendering, it must be inside a condition likeprevCount !== count, and there must be a call likesetPrevCount(count)inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of thecurrently renderingcomponent like this. Calling thesetfunction ofanothercomponent during rendering is an error. Finally, yoursetcall should stillupdate state without mutation‚Äî this doesn‚Äôt mean you can break other rules ofpure functions.This pattern can be hard to understand and is usually best avoided. However, it‚Äôs better than updating state in an effect. When you call thesetfunction during render, React will re-render that component immediately after your component exits with areturnstatement, and before rendering the children. This way, children don‚Äôt need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an earlyreturn;to restart rendering earlier.TroubleshootingI‚Äôve updated the state, but logging gives me the old valueCalling thesetfunctiondoes not change state in the running code:functionhandleClick(){console.log(count);// 0setCount(count+1);// Request a re-render with 1console.log(count);// Still 0!setTimeout(()=>{console.log(count);// Also 0!},5000);}This is becausestates behaves like a snapshot.Updating state requests another render with the new state value, but does not affect thecountJavaScript variable in your already-running event handler.If you need to use the next state, you can save it in a variable before passing it to thesetfunction:constnextCount=count+1;setCount(nextCount);console.log(count);// 0console.log(nextCount);// 1I‚Äôve updated the state, but the screen doesn‚Äôt updateReact willignore your update if the next state is equal to the previous state,as determined by anObject.iscomparison. This usually happens when you change an object or an array in state directly:obj.x=10;// üö© Wrong: mutating existing objectsetObj(obj);// üö© Doesn't do anythingYou mutated an existingobjobject and passed it back tosetObj, so React ignored the update. To fix this, you need to ensure that you‚Äôre alwaysreplacingobjects and arrays in state instead ofmutatingthem:// ‚úÖ Correct: creating a new objectsetObj({...obj,x:10});I‚Äôm getting an error: ‚ÄúToo many re-renders‚ÄùYou might get an error that says:Too many re-renders. React limits the number of renders to prevent an infinite loop.Typically, this means that you‚Äôre unconditionally setting stateduring render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:// üö© Wrong: calls the handler during renderreturn<buttononClick={handleClick()}>Click me</button>// ‚úÖ Correct: passes down the event handlerreturn<buttononClick={handleClick}>Click me</button>// ‚úÖ Correct: passes down an inline functionreturn<buttononClick={(e)=>handleClick(e)}>Click me</button>If you can‚Äôt find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specificsetfunction call responsible for the error.My initializer or updater function runs twiceInStrict Mode, React will call some of your functions twice instead of once:functionTodoList(){// This component function will run twice for every render.const[todos,setTodos]=useState(()=>{// This initializer function will run twice during initialization.returncreateTodos();});functionhandleClick(){setTodos(prevTodos=>{// This updater function will run twice for every click.return[...prevTodos,createTodo()];});}// ...This is expected and shouldn‚Äôt break your code.Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.For example, this impure updater function mutates an array in state:setTodos(prevTodos=>{// üö© Mistake: mutating stateprevTodos.push(createTodo());});Because React calls your updater function twice, you‚Äôll see the todo was added twice, so you‚Äôll know that there is a mistake. In this example, you can fix the mistake byreplacing the array instead of mutating it:setTodos(prevTodos=>{// ‚úÖ Correct: replacing with new statereturn[...prevTodos,createTodo()];});Now that this updater function is pure, calling it an extra time doesn‚Äôt make a difference in behavior. This is why React calling it twice helps you find mistakes.Only component, initializer, and updater functions need to be pure.Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.Readkeeping components pureto learn more.I‚Äôm trying to set state to a function, but it gets called insteadYou can‚Äôt put a function into state like this:const[fn,setFn]=useState(someFunction);functionhandleClick(){setFn(someOtherFunction);}Because you‚Äôre passing a function, React assumes thatsomeFunctionis aninitializer function, and thatsomeOtherFunctionis anupdater function, so it tries to call them and store the result. To actuallystorea function, you have to put() =>before them in both cases. Then React will store the functions you pass.const[fn,setFn]=useState(()=>someFunction);functionhandleClick(){setFn(()=>someOtherFunction);}PrevioususeRefNextuseSyncExternalStore",
      "metadata": {
        "source": "react-official",
        "url": "https://react.dev/reference/react/useState",
        "type": "documentation",
        "framework": "react",
        "fetched_at": 1757098348.64899
      }
    },
    {
      "content": "API ReferenceHooksuseEffectuseEffectis a React Hook that lets yousynchronize a component with an external system.useEffect(setup,dependencies?)ReferenceuseEffect(setup, dependencies?)UsageConnecting to an external systemWrapping Effects in custom HooksControlling a non-React widgetFetching data with EffectsSpecifying reactive dependenciesUpdating state based on previous state from an EffectRemoving unnecessary object dependenciesRemoving unnecessary function dependenciesReading the latest props and state from an EffectDisplaying different content on the server and the clientTroubleshootingMy Effect runs twice when the component mountsMy Effect runs after every re-renderMy Effect keeps re-running in an infinite cycleMy cleanup logic runs even though my component didn‚Äôt unmountMy Effect does something visual, and I see a flicker before it runsReferenceuseEffect(setup, dependencies?)CalluseEffectat the top level of your component to declare an Effect:import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);// ...}See more examples below.Parameterssetup: The function with your Effect‚Äôs logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every re-render of the component.See the difference between passing an array of dependencies, an empty array, and no dependencies at all.ReturnsuseEffectreturnsundefined.CaveatsuseEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.If you‚Äôrenot trying to synchronize with some external system,you probably don‚Äôt need an Effect.When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.If your Effect wasn‚Äôt caused by an interaction (like a click), React will generally let the browserpaint the updated screen first before running your Effect.If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replaceuseEffectwithuseLayoutEffect.If your Effect is caused by an interaction (like a click),React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as analert(), you can usesetTimeout. Seereactwg/react-18/128for more information.Even if your Effect was caused by an interaction (like a click),React may allow the browser to repaint the screen before processing the state updates inside your Effect.Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replaceuseEffectwithuseLayoutEffect.Effectsonly run on the client.They don‚Äôt run during server rendering.UsageConnecting to an external systemSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren‚Äôt controlled by React, so they are calledexternal.Toconnect your component to some external system,calluseEffectat the top level of your component:import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{const connection = createConnection(serverUrl, roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl, roomId]);// ...}You need to pass two arguments touseEffect:Asetup functionwithsetup codethat connects to that system.It should return acleanup functionwithcleanup codethat disconnects from that system.Alist of dependenciesincluding every value from your component used inside of those functions.React calls your setup and cleanup functions whenever it‚Äôs necessary, which may happen multiple times:Yoursetup coderuns when your component is added to the page(mounts).After every re-render of your component where thedependencieshave changed:First, yourcleanup coderuns with the old props and state.Then, yoursetup coderuns with the new props and state.Yourcleanup coderuns one final time after your component is removed from the page(unmounts).Let‚Äôs illustrate this sequence for the example above.When theChatRoomcomponent above gets added to the page, it will connect to the chat room with the initialserverUrlandroomId. If eitherserverUrlorroomIdchange as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect willdisconnect from the previous room, and connect to the next one.When theChatRoomcomponent is removed from the page, your Effect will disconnect one last time.Tohelp you find bugs,in development React runssetupandcleanupone extra time before thesetup.This is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and asetup‚Üícleanup‚Üísetupsequence (as in development).See common solutions.Try towrite every Effect as an independent processandthink about a single setup/cleanup cycle at a time.It shouldn‚Äôt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly ‚Äúmirrors‚Äù the setup logic, your Effect is resilient to running setup and cleanup as often as needed.NoteAn Effect lets youkeep your component synchronizedwith some external system (like a chat service). Here,external systemmeans any piece of code that‚Äôs not controlled by React, such as:A timer managed withsetInterval()andclearInterval().An event subscription usingwindow.addEventListener()andwindow.removeEventListener().A third-party animation library with an API likeanimation.start()andanimation.reset().If you‚Äôre not connecting to any external system,you probably don‚Äôt need an Effect.Examples of connecting to an external system1.Connecting to a chat server2.Listening to a global browser event3.Triggering an animation4.Controlling a modal dialog5.Tracking element visibilityExample1of5:Connecting to a chat serverIn this example, theChatRoomcomponent uses an Effect to stay connected to an external system defined inchat.js. Press ‚ÄúOpen chat‚Äù to make theChatRoomcomponent appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, asexplained here.Try changing theroomIdandserverUrlusing the dropdown and the input, and see how the Effect re-connects to the chat. Press ‚ÄúClose chat‚Äù to see the Effect disconnect one last time.App.jschat.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId,serverUrl]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}Show moreNextExampleWrapping Effects in custom HooksEffects are an‚Äúescape hatch‚Äù:you use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it‚Äôs usually a sign that you need to extract somecustom Hooksfor common behaviors your components rely on.For example, thisuseChatRoomcustom Hook ‚Äúhides‚Äù the logic of your Effect behind a more declarative API:functionuseChatRoom({serverUrl,roomId}){useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);}Then you can use it from any component like this:functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});// ...There are also many excellent custom Hooks for every purpose available in the React ecosystem.Learn more about wrapping Effects in custom Hooks.Examples of wrapping Effects in custom Hooks1.CustomuseChatRoomHook2.CustomuseWindowListenerHook3.CustomuseIntersectionObserverHookExample1of3:CustomuseChatRoomHookThis example is identical to one of theearlier examples,but the logic is extracted to a custom Hook.App.jsuseChatRoom.jschat.jsApp.jsReloadClearForkimport{useState}from'react';import{useChatRoom}from'./useChatRoom.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}Show moreNextExampleControlling a non-React widgetSometimes, you want to keep an external system synchronized to some prop or state of your component.For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of aMapWidgetclass defined inmap-widget.js. When you change thezoomLevelprop of theMapcomponent, the Effect calls thesetZoom()on the class instance to keep it synchronized:App.jsMap.jsmap-widget.jsMap.jsReloadClearForkimport{useRef,useEffect}from'react';import{MapWidget}from'./map-widget.js';exportdefaultfunctionMap({zoomLevel}){constcontainerRef=useRef(null);constmapRef=useRef(null);useEffect(()=>{if(mapRef.current===null){mapRef.current=newMapWidget(containerRef.current);}constmap=mapRef.current;map.setZoom(zoomLevel);},[zoomLevel]);return(<divstyle={{width:200,height:200}}ref={containerRef}/>);}Show moreIn this example, a cleanup function is not needed because theMapWidgetclass manages only the DOM node that was passed to it. After theMapReact component is removed from the tree, both the DOM node and theMapWidgetclass instance will be automatically garbage-collected by the browser JavaScript engine.Fetching data with EffectsYou can use an Effect to fetch data for your component. Note thatif you use a framework,using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually.If you want to fetch data from an Effect manually, your code might look like this:import{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{letignore=false;setBio(null);fetchBio(person).then(result=>{if(!ignore){setBio(result);}});return()=>{ignore=true;};},[person]);// ...Note theignorevariable which is initialized tofalse, and is set totrueduring cleanup. This ensuresyour code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù:network responses may arrive in a different order than you sent them.App.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{letignore=false;setBio(null);fetchBio(person).then(result=>{if(!ignore){setBio(result);}});return()=>{ignore=true;}},[person]);return(<><selectvalue={person}onChange={e=>{setPerson(e.target.value);}}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option><optionvalue=\"Taylor\">Taylor</option></select><hr/><p><i>{bio??'Loading...'}</i></p></>);}Show moreYou can also rewrite using theasync/awaitsyntax, but you still need to provide a cleanup function:App.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{asyncfunctionstartFetching(){setBio(null);constresult=awaitfetchBio(person);if(!ignore){setBio(result);}}letignore=false;startFetching();return()=>{ignore=true;}},[person]);return(<><selectvalue={person}onChange={e=>{setPerson(e.target.value);}}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option><optionvalue=\"Taylor\">Taylor</option></select><hr/><p><i>{bio??'Loading...'}</i></p></>);}Show moreWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later.It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community.Deep DiveWhat are good alternatives to data fetching in Effects?Show DetailsWritingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:Effects don‚Äôt run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.Fetching directly in Effects usually means you don‚Äôt preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.It‚Äôs not very ergonomic.There‚Äôs quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn‚Äôt suffer from bugs likerace conditions.This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.Otherwise, consider using or building a client-side cache.Popular open source solutions includeReact Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).You can continue fetching data directly in Effects if neither of these approaches suit you.Specifying reactive dependenciesNotice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect.Everyreactive valueused by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code:functionChatRoom({roomId}){// This is a reactive valueconst[serverUrl,setServerUrl]=useState('https://localhost:1234');// This is a reactive value toouseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// This Effect reads these reactive valuesconnection.connect();return()=>connection.disconnect();},[serverUrl,roomId]);// ‚úÖ So you must specify them as dependencies of your Effect// ...}If eitherserverUrlorroomIdchange, your Effect will reconnect to the chat using the new values.Reactive valuesinclude props and all variables and functions declared directly inside of your component.SinceroomIdandserverUrlare reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them andyour linter is correctly configured for React,the linter will flag this as a mistake you need to fix:functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// üî¥ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'// ...}To remove a dependency, you need to‚Äúprove‚Äù to the linter that itdoesn‚Äôt needto be a dependency.For example, you can moveserverUrlout of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders:constserverUrl='https://localhost:1234';// Not a reactive value anymorefunctionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);// ‚úÖ All dependencies declared// ...}Now thatserverUrlis not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency.If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ([]):constserverUrl='https://localhost:1234';// Not a reactive value anymoreconstroomId='music';// Not a reactive value anymorefunctionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// ‚úÖ All dependencies declared// ...}An Effect with empty dependenciesdoesn‚Äôt re-run when any of your component‚Äôs props or state change.PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(()=>{// ...// üî¥ Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps},[]);When dependencies don‚Äôt match the code, there is a high risk of introducing bugs.By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on.Instead, prove they‚Äôre unnecessary.Examples of passing reactive dependencies1.Passing a dependency array2.Passing an empty dependency array3.Passing no dependency array at allExample1of3:Passing a dependency arrayIf you specify the dependencies, your Effect runsafter the initial renderandafter re-renders with changed dependencies.useEffect(()=>{// ...},[a,b]);// Runs again if a or b are differentIn the below example,serverUrlandroomIdarereactive values,so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, sincemessageisn‚Äôt used in the Effect (and so it isn‚Äôt a dependency), editing the message doesn‚Äôt re-connect to the chat.App.jschat.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1><label>Your message:{' '}<inputvalue={message}onChange={e=>setMessage(e.target.value)}/></label></>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button></label>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}Show moreNextExampleUpdating state based on previous state from an EffectWhen you want to update state based on previous state from an Effect, you might run into a problem:functionCounter(){const[count,setCount]=useState(0);useEffect(()=>{constintervalId=setInterval(()=>{setCount(count+1);// You want to increment the counter every second...},1000)return()=>clearInterval(intervalId);},[count]);// üö© ... but specifying `count` as a dependency always resets the interval.// ...}Sincecountis a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time thecountchanges. This is not ideal.To fix this,pass thec => c + 1state updatertosetCount:App.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);useEffect(()=>{constintervalId=setInterval(()=>{setCount(c=>c+1);// ‚úÖ Pass a state updater},1000);return()=>clearInterval(intervalId);},[]);// ‚úÖ Now count is not a dependencyreturn<h1>{count}</h1>;}Now that you‚Äôre passingc => c + 1instead ofcount + 1,your Effect no longer needs to depend oncount.As a result of this fix, it won‚Äôt need to cleanup and setup the interval again every time thecountchanges.Removing unnecessary object dependenciesIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because theoptionsobject isdifferent for every render:constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');constoptions={// üö© This object is created from scratch on every re-renderserverUrl:serverUrl,roomId:roomId};useEffect(()=>{constconnection=createConnection(options);// It's used inside the Effectconnection.connect();return()=>connection.disconnect();},[options]);// üö© As a result, these dependencies are always different on a re-render// ...Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:App.jschat.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}Show moreNow that you create theoptionsobject inside the Effect, the Effect itself only depends on theroomIdstring.With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string likeroomIddoesn‚Äôt change unless you set it to another value.Read more about removing dependencies.Removing unnecessary function dependenciesIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because thecreateOptionsfunction isdifferent for every render:functionChatRoom({roomId}){const[message,setMessage]=useState('');functioncreateOptions(){// üö© This function is created from scratch on every re-renderreturn{serverUrl:serverUrl,roomId:roomId};}useEffect(()=>{constoptions=createOptions();// It's used inside the Effectconstconnection=createConnection();connection.connect();return()=>connection.disconnect();},[createOptions]);// üö© As a result, these dependencies are always different on a re-render// ...By itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:App.jschat.jsApp.jsReloadClearForkimport{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{functioncreateOptions(){return{serverUrl:serverUrl,roomId:roomId};}constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}Show moreNow that you define thecreateOptionsfunction inside the Effect, the Effect itself only depends on theroomIdstring. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike a function which gets re-created, a string likeroomIddoesn‚Äôt change unless you set it to another value.Read more about removing dependencies.Reading the latest props and state from an EffectUnder ConstructionThis section describes anexperimental API that has not yet been releasedin a stable version of React.By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect ‚Äúreacts‚Äù to every change of that value. For most dependencies, that‚Äôs the behavior you want.However, sometimes you‚Äôll want to read thelatestprops and state from an Effect without ‚Äúreacting‚Äù to them.For example, imagine you want to log the number of the items in the shopping cart for every page visit:functionPage({url,shoppingCart}){useEffect(()=>{logVisit(url,shoppingCart.length);},[url,shoppingCart]);// ‚úÖ All dependencies declared// ...}What if you want to log a new page visit after everyurlchange, butnotif only theshoppingCartchanges?You can‚Äôt excludeshoppingCartfrom dependencies without breaking thereactivity rules.However, you can express that youdon‚Äôt wanta piece of code to ‚Äúreact‚Äù to changes even though it is called from inside an Effect.Declare anEffect Eventwith theuseEffectEventHook, and move the code readingshoppingCartinside of it:functionPage({url,shoppingCart}){constonVisit=useEffectEvent(visitedUrl=>{logVisit(visitedUrl,shoppingCart.length)});useEffect(()=>{onVisit(url);},[url]);// ‚úÖ All dependencies declared// ...}Effect Events are not reactive and must always be omitted from dependencies of your Effect.This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By readingshoppingCartinside ofonVisit, you ensure thatshoppingCartwon‚Äôt re-run your Effect.Read more about how Effect Events let you separate reactive and non-reactive code.Displaying different content on the server and the clientIf your app uses server rendering (eitherdirectlyor via aframework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, forhydrationto work, your initial render output must be identical on the client and the server.In rare cases, you might need to display different content on the client. For example, if your app reads some data fromlocalStorage, it can‚Äôt possibly do that on the server. Here is how you could implement this:functionMyComponent(){const[didMount,setDidMount]=useState(false);useEffect(()=>{setDidMount(true);},[]);if(didMount){// ... return client-only JSX ...}else{// ... return initial JSX ...}}While the app is loading, the user will see the initial render output. Then, when it‚Äôs loaded and hydrated, your Effect will run and setdidMounttotrue, triggering a re-render. This will switch to the client-only render output. Effects don‚Äôt run on the server, so this is whydidMountwasfalseduring the initial server render.Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time‚Äîpotentially, many seconds‚Äîso you don‚Äôt want to make jarring changes to your component‚Äôs appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.TroubleshootingMy Effect runs twice when the component mountsWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.This is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development).Read more abouthow this helps find bugsandhow to fix your logic.My Effect runs after every re-renderFirst, check that you haven‚Äôt forgotten to specify the dependency array:useEffect(()=>{// ...});// üö© No dependency array: re-runs after every render!If you‚Äôve specified the dependency array but your Effect still re-runs in a loop, it‚Äôs because one of your dependencies is different on every re-render.You can debug this problem by manually logging your dependencies to the console:useEffect(()=>{// ..},[serverUrl,roomId]);console.log([serverUrl,roomId]);You can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:Object.is(temp1[0],temp2[0]);// Is the first dependency the same between the arrays?Object.is(temp1[1],temp2[1]);// Is the second dependency the same between the arrays?Object.is(temp1[2],temp2[2]);// ... and so on for every dependency ...When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:Updating state based on previous state from an EffectRemoving unnecessary object dependenciesRemoving unnecessary function dependenciesReading the latest props and state from an EffectAs a last resort (if these methods didn‚Äôt help), wrap its creation withuseMemooruseCallback(for functions).My Effect keeps re-running in an infinite cycleIf your Effect runs in an infinite cycle, these two things must be true:Your Effect is updating some state.That state leads to a re-render, which causes the Effect‚Äôs dependencies to change.Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application‚Äôs data flow with it?If there is no external system, consider whetherremoving the Effect altogetherwould simplify your logic.If you‚Äôre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component‚Äôs visual output? If you need to keep track of some data that isn‚Äôt used by rendering, aref(which doesn‚Äôt trigger re-renders) might be more appropriate. Verify your Effect doesn‚Äôt update the state (and trigger re-renders) more than needed.Finally, if your Effect is updating the state at the right time, but there is still a loop, it‚Äôs because that state update leads to one of the Effect‚Äôs dependencies changing.Read how to debug dependency changes.My cleanup logic runs even though my component didn‚Äôt unmountThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, Reactruns setup+cleanup one extra time immediately after component mounts.If you have cleanup code without corresponding setup code, it‚Äôs usually a code smell:useEffect(()=>{// üî¥ Avoid: Cleanup logic without corresponding setup logicreturn()=>{doSomething();};},[]);Your cleanup logic should be ‚Äúsymmetrical‚Äù to the setup logic, and should stop or undo whatever setup did:useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);Learn how the Effect lifecycle is different from the component‚Äôs lifecycle.My Effect does something visual, and I see a flicker before it runsIf your Effect must block the browser frompainting the screen,replaceuseEffectwithuseLayoutEffect. Note thatthis shouldn‚Äôt be needed for the vast majority of Effects.You‚Äôll only need this if it‚Äôs crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.PrevioususeDeferredValueNextuseId",
      "metadata": {
        "source": "react-official",
        "url": "https://react.dev/reference/react/useEffect",
        "type": "documentation",
        "framework": "react",
        "fetched_at": 1757098354.916543
      }
    },
    {
      "content": "App RouterGetting StartedFetching DataCopy pageFetching DataThis page will walk you through how you can fetch data inServer and Client Components, and how tostreamcomponents that depend on data.Fetching dataServer ComponentsYou can fetch data in Server Components using:ThefetchAPIAnORM or databaseWith thefetchAPITo fetch data with thefetchAPI, turn your component into an asynchronous function, and await thefetchcall. For example:app/blog/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}Good to know:fetchresponses are not cached by default. However, Next.js willprerenderthe route and the output will be cached for improved performance. If you'd like to opt intodynamic rendering, use the{ cache: 'no-store' }option. See thefetchAPI Reference.During development, you can logfetchcalls for better visibility and debugging. See theloggingAPI reference.With an ORM or databaseSince Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ db,posts }from'@/lib/db'exportdefaultasyncfunctionPage() {constallPosts=awaitdb.select().from(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}Client ComponentsThere are two ways to fetch data in Client Components, using:React'susehookA community library likeSWRorReact QueryStreaming data with theusehookYou can use React'susehooktostreamdata from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimportPostsfrom'@/app/ui/posts'import{ Suspense }from'react'exportdefaultfunctionPage() {// Don't await the data fetching functionconstposts=getPosts()return(<Suspensefallback={<div>Loading...</div>}><Postsposts={posts} /></Suspense>)}Then, in your Client Component, use theusehook to read the promise:app/ui/posts.tsxTypeScriptJavaScriptTypeScript'use client'import{ use }from'react'exportdefaultfunctionPosts({posts,}:{posts:Promise<{ id:string; title:string}[]>}) {constallPosts=use(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}In the example above, the<Posts>component is wrapped in a<Suspense>boundary. This means the fallback will be shown while the promise is being resolved. Learn more aboutstreaming.Community librariesYou can use a community library likeSWRorReact Queryto fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:app/blog/page.tsxTypeScriptJavaScriptTypeScript'use client'importuseSWRfrom'swr'constfetcher=(url)=>fetch(url).then((r)=>r.json())exportdefaultfunctionBlogPage() {const{data,error,isLoading}=useSWR('https://api.vercel.app/blog',fetcher)if(isLoading)return<div>Loading...</div>if(error)return<div>Error: {error.message}</div>return(<ul>{data.map((post:{ id:string; title:string})=>(<likey={post.id}>{post.title}</li>))}</ul>)}Deduplicate requests and cache dataOne way to deduplicatefetchrequests is withrequest memoization. With this mechanism,fetchcalls usingGETorHEADwith the same URL and options in a single render pass are combined into one request. This happens automatically, and you canopt outby passing an Abort signal tofetch.Request memoization is scoped to the lifetime of a request.You can also deduplicatefetchrequests by using Next.js‚ÄôData Cache, for example by settingcache: 'force-cache'in yourfetchoptions.Data Cache allows sharing data across the current render pass and incoming requests.If you arenotusingfetch, and instead using an ORM or database directly, you can wrap your data access with theReactcachefunction.app/lib/data.tsTypeScriptJavaScriptTypeScriptimport{ cache }from'react'import{ db,posts,eq }from'@/lib/db'exportconstgetPost=cache(async(id:string)=>{constpost=awaitdb.query.posts.findFirst({where:eq(posts.id,parseInt(id)),})})StreamingWarning:The content below assumes thecacheComponentsconfig optionis enabled in your application. The flag was introduced in Next.js 15 canary.When usingasync/awaitin Server Components, Next.js will opt intodynamic rendering. This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.There are two ways you can implement streaming in your application:Wrapping a page with aloading.jsfileWrapping a component with<Suspense>Withloading.jsYou can create aloading.jsfile in the same folder as your page to stream theentire pagewhile the data is being fetched. For example, to streamapp/blog/page.js, add the file inside theapp/blogfolder.app/blog/loading.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLoading() {// Define the Loading UI herereturn<div>Loading...</div>}On navigation, the user will immediately see the layout and aloading statewhile the page is being rendered. The new content will then be automatically swapped in once rendering is complete.Behind-the-scenes,loading.jswill be nested insidelayout.js, and will automatically wrap thepage.jsfile and any children below in a<Suspense>boundary.This approach works well for route segments (layouts and pages), but for more granular streaming, you can use<Suspense>.With<Suspense><Suspense>allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the<Suspense>boundary, and stream in the list of blog posts inside the boundary.app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'importBlogListfrom'@/components/BlogList'importBlogListSkeletonfrom'@/components/BlogListSkeleton'exportdefaultfunctionBlogPage() {return(<div>{/* This content will be sent to the client immediately */}<header><h1>Welcome to the Blog</h1><p>Read the latest posts below.</p></header><main>{/* Any content wrapped in a <Suspense> boundary will be streamed */}<Suspensefallback={<BlogListSkeleton/>}><BlogList/></Suspense></main></div>)}Creating meaningful loading statesAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.In development, you can preview and inspect the loading state of your components using theReact Devtools.ExamplesSequential data fetchingSequential data fetching happens when nested components in a tree each fetch their own data and the requests are notdeduplicated, leading to longer response times.There may be cases where you want this pattern because one fetch depends on the result of the other.For example, the<Playlists>component will only start fetching data once the<Artist>component has finished fetching data because<Playlists>depends on theartistIDprop:app/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparams// Getartistinformationconstartist=awaitgetArtist(username)return(<><h1>{artist.name}</h1>{/* Show fallback UI while the Playlists component is loading */}<Suspensefallback={<div>Loading...</div>}>{/* Pass theartistID to the Playlists component */}<PlaylistsartistID={artist.id} /></Suspense></>)}asyncfunctionPlaylists({artistID }:{artistID:string}) {// Use theartistID to fetch playlistsconstplaylists=awaitgetArtistPlaylists(artistID)return(<ul>{playlists.map((playlist)=>(<likey={playlist.id}>{playlist.name}</li>))}</ul>)}To improve the user experience, you should useReact<Suspense>to show afallbackwhile data is being fetch. This will enablestreamingand prevent the whole route from being blocked by the sequential data requests.Parallel data fetchingParallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.By default,layouts and pagesare rendered in parallel. So each segment starts fetching data as soon as possible.However, withinanycomponent, multipleasync/awaitrequests can still be sequential if placed after the other. For example,getAlbumswill be blocked untilgetArtistis resolved:app/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptimport{ getArtist,getAlbums }from'@/app/lib/data'exportdefaultasyncfunctionPage({ params }) {// These requests will be sequentialconst{username}=awaitparamsconstartist=awaitgetArtist(username)constalbums=awaitgetAlbums(username)return<div>{artist.name}</div>}Start multiple requests by callingfetch, then await them withPromise.all. Requests begin as soon asfetchis called.app/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptimportAlbumsfrom'./albums'asyncfunctiongetArtist(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}`)returnres.json()}asyncfunctiongetAlbums(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}/albums`)returnres.json()}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparams// Initiate requestsconstartistData=getArtist(username)constalbumsData=getAlbums(username)const[artist,albums]=awaitPromise.all([artistData,albumsData])return(<><h1>{artist.name}</h1><Albumslist={albums} /></>)}Good to know:If one request fails when usingPromise.all, the entire operation will fail. To handle this, you can use thePromise.allSettledmethod instead.Preloading dataYou can preload data by creating an utility function that you eagerly call above blocking requests.<Item>conditionally renders based on thecheckIsAvailable()function.You can callpreload()beforecheckIsAvailable()to eagerly initiate<Item/>data dependencies. By the time<Item/>is rendered, its data has already been fetched.app/item/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport{ getItem,checkIsAvailable }from'@/lib/data'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparams// starting loadingitemdatapreload(id)// perform another asynchronous taskconstisAvailable=awaitcheckIsAvailable()returnisAvailable?<Itemid={id} />:null}exportconstpreload=(id:string)=>{// void evaluates the given expression and returns undefined// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/voidvoidgetItem(id)}exportasyncfunctionItem({ id }:{ id:string}) {constresult=awaitgetItem(id)// ...}Additionally, you can use React'scachefunctionand theserver-onlypackageto create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.utils/get-item.tsTypeScriptJavaScriptTypeScriptimport{ cache }from'react'import'server-only'import{ getItem }from'@/lib/data'exportconstpreload=(id:string)=>{voidgetItem(id)}exportconstgetItem=cache(async(id:string)=>{// ...})API ReferenceLearn more about the features mentioned in this page by reading the API Reference.Data SecurityLearn the built-in data security features in Next.js and learn best practices for protecting your application's data.fetchAPI reference for the extended fetch function.loading.jsAPI reference for the loading.js file.loggingConfigure how data fetches are logged to the console when running Next.js in development mode.taintEnable tainting Objects and Values.PreviousPartial PrerenderingNextUpdating DataWas this helpful?supported.Send",
      "metadata": {
        "source": "nextjs-official",
        "url": "https://nextjs.org/docs/app/building-your-application/data-fetching",
        "type": "documentation",
        "framework": "nextjs",
        "fetched_at": 1757098361.8557975
      }
    },
    {
      "content": "App RouterGetting StartedServer and Client ComponentsCopy pageServer and Client ComponentsBy default, layouts and pages areServer Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can useClient Componentsto layer in functionality.This page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.When to use Server and Client Components?The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.UseClient Componentswhen you need:Stateandevent handlers. E.g.onClick,onChange.Lifecycle logic. E.g.useEffect.Browser-only APIs. E.g.localStorage,window,Navigator.geolocation, etc.Custom hooks.UseServer Componentswhen you need:Fetch data from databases or APIs close to the source.Use API keys, tokens, and other secrets without exposing them to the client.Reduce the amount of JavaScript sent to the browser.Improve theFirst Contentful Paint (FCP), and stream content progressively to the client.For example, the<Page>component is a Server Component that fetches data about a post, and passes it as props to the<LikeButton>which handles client-side interactivity.app/[id]/page.tsxTypeScriptJavaScriptTypeScriptimportLikeButtonfrom'@/app/ui/like-button'import{ getPost }from'@/lib/data'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return(<div><main><h1>{post.title}</h1>{/* ... */}<LikeButtonlikes={post.likes} /></main></div>)}app/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionLikeButton({ likes }:{ likes:number}) {// ...}How do Server and Client Components work in Next.js?On the serverOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages):Server Componentsare rendered into a special data format called the React Server Component Payload (RSC Payload).Client Componentsand the RSC Payload are used toprerenderHTML.What is the React Server Component Payload (RSC)?The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:The rendered result of Server ComponentsPlaceholders for where Client Components should be rendered and references to their JavaScript filesAny props passed from a Server Component to a Client ComponentOn the client (first load)Then, on the client:HTMLis used to immediately show a fast non-interactive preview of the route to the user.RSC Payloadis used to reconcile the Client and Server Component trees.JavaScriptis used to hydrate Client Components and make the application interactive.What is hydration?Hydration is React's process for attachingevent handlersto the DOM, to make the static HTML interactive.Subsequent NavigationsOn subsequent navigations:TheRSC Payloadis prefetched and cached for instant navigation.Client Componentsare rendered entirely on the client, without the server-rendered HTML.ExamplesUsing Client ComponentsYou can create a Client Component by adding the\"use client\"directive at the top of the file, above your imports.app/ui/counter.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionCounter() {const[count,setCount]=useState(0)return(<div><p>{count} likes</p><buttononClick={()=>setCount(count+1)}>Click me</button></div>)}\"use client\"is used to declare aboundarybetween the Server and Client module graphs (trees).Once a file is marked with\"use client\",all its imports and child components are considered part of the client bundle. This means you don't need to add the directive to every component that is intended for the client.Reducing JS bundle sizeTo reduce the size of your client JavaScript bundles, add'use client'to specific interactive components instead of marking large parts of your UI as Client Components.For example, the<Layout>component contains mostly static elements like a logo and navigation links, but includes an interactive search bar.<Search />is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.app/layout.tsxTypeScriptJavaScriptTypeScript// Client ComponentimportSearchfrom'./search'// Server ComponentimportLogofrom'./logo'// Layout is a Server Component by defaultexportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Logo/><Search/></nav><main>{children}</main></>)}app/ui/search.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionSearch() {// ...}Passing data from Server to Client ComponentsYou can pass data from Server Components to Client Components using props.app/[id]/page.tsxTypeScriptJavaScriptTypeScriptimportLikeButtonfrom'@/app/ui/like-button'import{ getPost }from'@/lib/data'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return<LikeButtonlikes={post.likes} />}app/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionLikeButton({ likes }:{ likes:number}) {// ...}Alternatively, you can stream data from a Server Component to a Client Component with theuseHook. See anexample.Good to know: Props passed to Client Components need to beserializableby React.Interleaving Server and Client ComponentsYou can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components.A common pattern is to usechildrento create aslotin a<ClientComponent>. For example, a<Cart>component that fetches data on the server, inside a<Modal>component that uses client state to toggle visibility.app/ui/modal.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionModal({ children }:{ children:React.ReactNode}) {return<div>{children}</div>}Then, in a parent Server Component (e.g.<Page>), you can pass a<Cart>as the child of the<Modal>:app/page.tsxTypeScriptJavaScriptTypeScriptimportModalfrom'./ui/modal'importCartfrom'./ui/cart'exportdefaultfunctionPage() {return(<Modal><Cart/></Modal>)}In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.Context providersReact contextis commonly used to share global state like the current theme. However, React context is not supported in Server Components.To use context, create a Client Component that acceptschildren:app/theme-provider.tsxTypeScriptJavaScriptTypeScript'use client'import{ createContext }from'react'exportconstThemeContext=createContext({})exportdefaultfunctionThemeProvider({children,}:{children:React.ReactNode}) {return<ThemeContext.Providervalue=\"dark\">{children}</ThemeContext.Provider>}Then, import it into a Server Component (e.g.layout):app/layout.tsxTypeScriptJavaScriptTypeScriptimportThemeProviderfrom'./theme-provider'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeProvider>{children}</ThemeProvider></body></html>)}Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context.Good to know: You should render providers as deep as possible in the tree ‚Äì notice howThemeProvideronly wraps{children}instead of the entire<html>document. This makes it easier for Next.js to optimize the static parts of your Server Components.Third-party componentsWhen using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.For example, the<Carousel />can be imported from theacme-carouselpackage. This component usesuseState, but it doesn't yet have the\"use client\"directive.If you use<Carousel />within a Client Component, it will work as expected:app/gallery.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'import{ Carousel }from'acme-carousel'exportdefaultfunctionGallery() {const[isOpen,setIsOpen]=useState(false)return(<div><buttononClick={()=>setIsOpen(true)}>View pictures</button>{/* Works, since Carousel is used within a Client Component */}{isOpen&&<Carousel/>}</div>)}However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know<Carousel />is using client-only features.To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:app/carousel.tsxTypeScriptJavaScriptTypeScript'use client'import{ Carousel }from'acme-carousel'exportdefaultCarouselNow, you can use<Carousel />directly within a Server Component:app/page.tsxTypeScriptJavaScriptTypeScriptimportCarouselfrom'./carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/*  Works, since Carousel is a Client Component */}<Carousel/></div>)}Advice for Library AuthorsIf you‚Äôre building a component library, add the\"use client\"directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers.It's worth noting some bundlers might strip out\"use client\"directives. You can find an example of how to configure esbuild to include the\"use client\"directive in theReact Wrap BalancerandVercel Analyticsrepositories.Preventing environment poisoningJavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function:lib/data.tsTypeScriptJavaScriptTypeScriptexportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}This function contains anAPI_KEYthat should never be exposed to the client.In Next.js, only environment variables prefixed withNEXT_PUBLIC_are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string.As a result, even thoughgetData()can be imported and executed on the client, it won't work as expected.To prevent accidental usage in Client Components, you can use theserver-onlypackage.Then, import the package into a file that contains server-only code:lib/data.jsimport'server-only'exportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}Now, if you try to import the module into a Client Component, there will be a build-time error.The correspondingclient-onlypackagecan be used to mark modules that contain client-only logic like code that accesses thewindowobject.In Next.js, installingserver-onlyorclient-onlyisoptional. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues.pnpmnpmyarnbunTerminalpnpmaddserver-onlyNext.js handlesserver-onlyandclient-onlyimports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js.Next.js also provides its own type declarations forserver-onlyandclient-only, for TypeScript configurations wherenoUncheckedSideEffectImportsis active.Next StepsLearn more about the APIs mentioned in this page.use clientLearn how to use the use client directive to render a component on the client.PreviousLinking and NavigatingNextPartial PrerenderingWas this helpful?supported.Send",
      "metadata": {
        "source": "nextjs-official",
        "url": "https://nextjs.org/docs/app/building-your-application/rendering/client-components",
        "type": "documentation",
        "framework": "nextjs",
        "fetched_at": 1757098368.6191602
      }
    },
    {
      "content": "App RouterGetting StartedServer and Client ComponentsCopy pageServer and Client ComponentsBy default, layouts and pages areServer Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can useClient Componentsto layer in functionality.This page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.When to use Server and Client Components?The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.UseClient Componentswhen you need:Stateandevent handlers. E.g.onClick,onChange.Lifecycle logic. E.g.useEffect.Browser-only APIs. E.g.localStorage,window,Navigator.geolocation, etc.Custom hooks.UseServer Componentswhen you need:Fetch data from databases or APIs close to the source.Use API keys, tokens, and other secrets without exposing them to the client.Reduce the amount of JavaScript sent to the browser.Improve theFirst Contentful Paint (FCP), and stream content progressively to the client.For example, the<Page>component is a Server Component that fetches data about a post, and passes it as props to the<LikeButton>which handles client-side interactivity.app/[id]/page.tsxTypeScriptJavaScriptTypeScriptimportLikeButtonfrom'@/app/ui/like-button'import{ getPost }from'@/lib/data'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return(<div><main><h1>{post.title}</h1>{/* ... */}<LikeButtonlikes={post.likes} /></main></div>)}app/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionLikeButton({ likes }:{ likes:number}) {// ...}How do Server and Client Components work in Next.js?On the serverOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages):Server Componentsare rendered into a special data format called the React Server Component Payload (RSC Payload).Client Componentsand the RSC Payload are used toprerenderHTML.What is the React Server Component Payload (RSC)?The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:The rendered result of Server ComponentsPlaceholders for where Client Components should be rendered and references to their JavaScript filesAny props passed from a Server Component to a Client ComponentOn the client (first load)Then, on the client:HTMLis used to immediately show a fast non-interactive preview of the route to the user.RSC Payloadis used to reconcile the Client and Server Component trees.JavaScriptis used to hydrate Client Components and make the application interactive.What is hydration?Hydration is React's process for attachingevent handlersto the DOM, to make the static HTML interactive.Subsequent NavigationsOn subsequent navigations:TheRSC Payloadis prefetched and cached for instant navigation.Client Componentsare rendered entirely on the client, without the server-rendered HTML.ExamplesUsing Client ComponentsYou can create a Client Component by adding the\"use client\"directive at the top of the file, above your imports.app/ui/counter.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionCounter() {const[count,setCount]=useState(0)return(<div><p>{count} likes</p><buttononClick={()=>setCount(count+1)}>Click me</button></div>)}\"use client\"is used to declare aboundarybetween the Server and Client module graphs (trees).Once a file is marked with\"use client\",all its imports and child components are considered part of the client bundle. This means you don't need to add the directive to every component that is intended for the client.Reducing JS bundle sizeTo reduce the size of your client JavaScript bundles, add'use client'to specific interactive components instead of marking large parts of your UI as Client Components.For example, the<Layout>component contains mostly static elements like a logo and navigation links, but includes an interactive search bar.<Search />is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.app/layout.tsxTypeScriptJavaScriptTypeScript// Client ComponentimportSearchfrom'./search'// Server ComponentimportLogofrom'./logo'// Layout is a Server Component by defaultexportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Logo/><Search/></nav><main>{children}</main></>)}app/ui/search.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionSearch() {// ...}Passing data from Server to Client ComponentsYou can pass data from Server Components to Client Components using props.app/[id]/page.tsxTypeScriptJavaScriptTypeScriptimportLikeButtonfrom'@/app/ui/like-button'import{ getPost }from'@/lib/data'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return<LikeButtonlikes={post.likes} />}app/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionLikeButton({ likes }:{ likes:number}) {// ...}Alternatively, you can stream data from a Server Component to a Client Component with theuseHook. See anexample.Good to know: Props passed to Client Components need to beserializableby React.Interleaving Server and Client ComponentsYou can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components.A common pattern is to usechildrento create aslotin a<ClientComponent>. For example, a<Cart>component that fetches data on the server, inside a<Modal>component that uses client state to toggle visibility.app/ui/modal.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionModal({ children }:{ children:React.ReactNode}) {return<div>{children}</div>}Then, in a parent Server Component (e.g.<Page>), you can pass a<Cart>as the child of the<Modal>:app/page.tsxTypeScriptJavaScriptTypeScriptimportModalfrom'./ui/modal'importCartfrom'./ui/cart'exportdefaultfunctionPage() {return(<Modal><Cart/></Modal>)}In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.Context providersReact contextis commonly used to share global state like the current theme. However, React context is not supported in Server Components.To use context, create a Client Component that acceptschildren:app/theme-provider.tsxTypeScriptJavaScriptTypeScript'use client'import{ createContext }from'react'exportconstThemeContext=createContext({})exportdefaultfunctionThemeProvider({children,}:{children:React.ReactNode}) {return<ThemeContext.Providervalue=\"dark\">{children}</ThemeContext.Provider>}Then, import it into a Server Component (e.g.layout):app/layout.tsxTypeScriptJavaScriptTypeScriptimportThemeProviderfrom'./theme-provider'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeProvider>{children}</ThemeProvider></body></html>)}Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context.Good to know: You should render providers as deep as possible in the tree ‚Äì notice howThemeProvideronly wraps{children}instead of the entire<html>document. This makes it easier for Next.js to optimize the static parts of your Server Components.Third-party componentsWhen using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.For example, the<Carousel />can be imported from theacme-carouselpackage. This component usesuseState, but it doesn't yet have the\"use client\"directive.If you use<Carousel />within a Client Component, it will work as expected:app/gallery.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'import{ Carousel }from'acme-carousel'exportdefaultfunctionGallery() {const[isOpen,setIsOpen]=useState(false)return(<div><buttononClick={()=>setIsOpen(true)}>View pictures</button>{/* Works, since Carousel is used within a Client Component */}{isOpen&&<Carousel/>}</div>)}However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know<Carousel />is using client-only features.To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:app/carousel.tsxTypeScriptJavaScriptTypeScript'use client'import{ Carousel }from'acme-carousel'exportdefaultCarouselNow, you can use<Carousel />directly within a Server Component:app/page.tsxTypeScriptJavaScriptTypeScriptimportCarouselfrom'./carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/*  Works, since Carousel is a Client Component */}<Carousel/></div>)}Advice for Library AuthorsIf you‚Äôre building a component library, add the\"use client\"directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers.It's worth noting some bundlers might strip out\"use client\"directives. You can find an example of how to configure esbuild to include the\"use client\"directive in theReact Wrap BalancerandVercel Analyticsrepositories.Preventing environment poisoningJavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function:lib/data.tsTypeScriptJavaScriptTypeScriptexportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}This function contains anAPI_KEYthat should never be exposed to the client.In Next.js, only environment variables prefixed withNEXT_PUBLIC_are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string.As a result, even thoughgetData()can be imported and executed on the client, it won't work as expected.To prevent accidental usage in Client Components, you can use theserver-onlypackage.Then, import the package into a file that contains server-only code:lib/data.jsimport'server-only'exportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}Now, if you try to import the module into a Client Component, there will be a build-time error.The correspondingclient-onlypackagecan be used to mark modules that contain client-only logic like code that accesses thewindowobject.In Next.js, installingserver-onlyorclient-onlyisoptional. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues.pnpmnpmyarnbunTerminalpnpmaddserver-onlyNext.js handlesserver-onlyandclient-onlyimports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js.Next.js also provides its own type declarations forserver-onlyandclient-only, for TypeScript configurations wherenoUncheckedSideEffectImportsis active.Next StepsLearn more about the APIs mentioned in this page.use clientLearn how to use the use client directive to render a component on the client.PreviousLinking and NavigatingNextPartial PrerenderingWas this helpful?supported.Send",
      "metadata": {
        "source": "nextjs-official",
        "url": "https://nextjs.org/docs/app/building-your-application/rendering/server-components",
        "type": "documentation",
        "framework": "nextjs",
        "fetched_at": 1757098375.350446
      }
    }
  ],
  "cached_at": 1757098376.3645506,
  "total_count": 7,
  "sources_used": {
    "react": true,
    "nextjs": true,
    "local": true,
    "sample": true
  }
}